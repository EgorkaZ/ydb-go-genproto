// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.17.3
// source: ydb_persqueue_v0.proto

package Ydb_PersQueue_V0

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PersQueueServiceClient is the client API for PersQueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PersQueueServiceClient interface {
	//*
	// Creates Write Session
	// Pipeline:
	// client                  server
	//         Init(Topic, SourceId, ...)
	//        ---------------->
	//         Init(Partition, MaxSeqNo, ...)
	//        <----------------
	//         write(data1, seqNo1)
	//        ---------------->
	//         write(data2, seqNo2)
	//        ---------------->
	//         ack(seqNo1, offset1, ...)
	//        <----------------
	//         write(data3, seqNo3)
	//        ---------------->
	//         ack(seqNo2, offset2, ...)
	//        <----------------
	//         persqueueError(description, errorCode)
	//        <----------------
	WriteSession(ctx context.Context, opts ...grpc.CallOption) (PersQueueService_WriteSessionClient, error)
	//*
	// Creates Read Session
	// Pipeline:
	// client                  server
	//         Init(Topics, ClientId, ...)
	//        ---------------->
	//         Init(SessionId)
	//        <----------------
	//         read1
	//        ---------------->
	//         read2
	//        ---------------->
	//         lock(Topic1,Partition1, ...) - locks and releases are optional
	//        <----------------
	//         lock(Topic2, Partition2, ...)
	//        <----------------
	//         release(Topic1, Partition1, ...)
	//        <----------------
	//         locked(Topic2, Partition2, ...) - client must respond to lock request with this message. Only after this client will start recieving messages from this partition
	//        ---------------->
	//         read result(data, ...)
	//        <----------------
	//         commit(cookie1)
	//        ---------------->
	//         commit result(cookie1)
	//        <----------------
	//         persqueueError(description, errorCode)
	//        <----------------
	ReadSession(ctx context.Context, opts ...grpc.CallOption) (PersQueueService_ReadSessionClient, error)
}

type persQueueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPersQueueServiceClient(cc grpc.ClientConnInterface) PersQueueServiceClient {
	return &persQueueServiceClient{cc}
}

func (c *persQueueServiceClient) WriteSession(ctx context.Context, opts ...grpc.CallOption) (PersQueueService_WriteSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &PersQueueService_ServiceDesc.Streams[0], "/NPersQueue.PersQueueService/WriteSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &persQueueServiceWriteSessionClient{stream}
	return x, nil
}

type PersQueueService_WriteSessionClient interface {
	Send(*WriteRequest) error
	Recv() (*WriteResponse, error)
	grpc.ClientStream
}

type persQueueServiceWriteSessionClient struct {
	grpc.ClientStream
}

func (x *persQueueServiceWriteSessionClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *persQueueServiceWriteSessionClient) Recv() (*WriteResponse, error) {
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *persQueueServiceClient) ReadSession(ctx context.Context, opts ...grpc.CallOption) (PersQueueService_ReadSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &PersQueueService_ServiceDesc.Streams[1], "/NPersQueue.PersQueueService/ReadSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &persQueueServiceReadSessionClient{stream}
	return x, nil
}

type PersQueueService_ReadSessionClient interface {
	Send(*ReadRequest) error
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type persQueueServiceReadSessionClient struct {
	grpc.ClientStream
}

func (x *persQueueServiceReadSessionClient) Send(m *ReadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *persQueueServiceReadSessionClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PersQueueServiceServer is the server API for PersQueueService service.
// All implementations must embed UnimplementedPersQueueServiceServer
// for forward compatibility
type PersQueueServiceServer interface {
	//*
	// Creates Write Session
	// Pipeline:
	// client                  server
	//         Init(Topic, SourceId, ...)
	//        ---------------->
	//         Init(Partition, MaxSeqNo, ...)
	//        <----------------
	//         write(data1, seqNo1)
	//        ---------------->
	//         write(data2, seqNo2)
	//        ---------------->
	//         ack(seqNo1, offset1, ...)
	//        <----------------
	//         write(data3, seqNo3)
	//        ---------------->
	//         ack(seqNo2, offset2, ...)
	//        <----------------
	//         persqueueError(description, errorCode)
	//        <----------------
	WriteSession(PersQueueService_WriteSessionServer) error
	//*
	// Creates Read Session
	// Pipeline:
	// client                  server
	//         Init(Topics, ClientId, ...)
	//        ---------------->
	//         Init(SessionId)
	//        <----------------
	//         read1
	//        ---------------->
	//         read2
	//        ---------------->
	//         lock(Topic1,Partition1, ...) - locks and releases are optional
	//        <----------------
	//         lock(Topic2, Partition2, ...)
	//        <----------------
	//         release(Topic1, Partition1, ...)
	//        <----------------
	//         locked(Topic2, Partition2, ...) - client must respond to lock request with this message. Only after this client will start recieving messages from this partition
	//        ---------------->
	//         read result(data, ...)
	//        <----------------
	//         commit(cookie1)
	//        ---------------->
	//         commit result(cookie1)
	//        <----------------
	//         persqueueError(description, errorCode)
	//        <----------------
	ReadSession(PersQueueService_ReadSessionServer) error
	mustEmbedUnimplementedPersQueueServiceServer()
}

// UnimplementedPersQueueServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPersQueueServiceServer struct {
}

func (UnimplementedPersQueueServiceServer) WriteSession(PersQueueService_WriteSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteSession not implemented")
}
func (UnimplementedPersQueueServiceServer) ReadSession(PersQueueService_ReadSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadSession not implemented")
}
func (UnimplementedPersQueueServiceServer) mustEmbedUnimplementedPersQueueServiceServer() {}

// UnsafePersQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PersQueueServiceServer will
// result in compilation errors.
type UnsafePersQueueServiceServer interface {
	mustEmbedUnimplementedPersQueueServiceServer()
}

func RegisterPersQueueServiceServer(s grpc.ServiceRegistrar, srv PersQueueServiceServer) {
	s.RegisterService(&PersQueueService_ServiceDesc, srv)
}

func _PersQueueService_WriteSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PersQueueServiceServer).WriteSession(&persQueueServiceWriteSessionServer{stream})
}

type PersQueueService_WriteSessionServer interface {
	Send(*WriteResponse) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type persQueueServiceWriteSessionServer struct {
	grpc.ServerStream
}

func (x *persQueueServiceWriteSessionServer) Send(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *persQueueServiceWriteSessionServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PersQueueService_ReadSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PersQueueServiceServer).ReadSession(&persQueueServiceReadSessionServer{stream})
}

type PersQueueService_ReadSessionServer interface {
	Send(*ReadResponse) error
	Recv() (*ReadRequest, error)
	grpc.ServerStream
}

type persQueueServiceReadSessionServer struct {
	grpc.ServerStream
}

func (x *persQueueServiceReadSessionServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *persQueueServiceReadSessionServer) Recv() (*ReadRequest, error) {
	m := new(ReadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PersQueueService_ServiceDesc is the grpc.ServiceDesc for PersQueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PersQueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "NPersQueue.PersQueueService",
	HandlerType: (*PersQueueServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WriteSession",
			Handler:       _PersQueueService_WriteSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadSession",
			Handler:       _PersQueueService_ReadSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "ydb_persqueue_v0.proto",
}
